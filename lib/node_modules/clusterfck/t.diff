diff --git a/README.md b/README.md
index d55846b..27d0d02 100644
--- a/README.md
+++ b/README.md
@@ -26,10 +26,11 @@ var colors = [
    [255, 13, 8]
 ];
 
+// Calculate clusters.
 var clusters = clusterfck.kmeans(colors, 3);
 ```
 
-The second argument to `kmeans` is the number of clusters you want (default is `Math.sqrt(n/2)` where `n` is the number of vectors). It returns an array of the clusters, for this example:
+The second argument to `kmeans` is the number of clusters you want (default is `Math.sqrt(n/2)` where `n` is the number of vectors). The kmeans() method returns an array of clusters, for this example:
 
 ```javascript
 [
@@ -39,6 +40,63 @@ The second argument to `kmeans` is the number of clusters you want (default is `
 ]
 ```
 
+#### Classification
+
+For classification, instantiate a new Kmeans() object.
+
+```javascript
+var kmeans = new clusterfck.Kmeans();
+
+// Calculate clusters.
+var clusters = kmeans.cluster(colors, 3);
+
+// Calculate cluster index for a new data point.
+var clusterIndex = kmeans.classify([0, 0, 225]);
+```
+
+#### Serialization
+
+The toJSON() and fromJSON() methods are available for serialization.
+
+```javascript
+// Serialize centroids to JSON.
+var json = kmeans.toJSON();
+
+// Deserialize centroids from JSON.
+kmeans = kmeans.fromJSON(json);
+
+// Calculate cluster index from a previously serialized set of centroids.
+var clusterIndex = kmeans.classify([0, 0, 225]);
+```
+
+#### Initializing with Existing Centroids
+
+```javascript
+// Take existing centroids, perhaps from a database?
+var centroids = [ [ 35.5, 31.5, 85 ], [ 250, 255, 253 ], [ 227.5, 6.5, 15.5 ] ];
+
+// Initialize constructor with centroids.
+var kmeans = new clusterfck.Kmeans(centroids);
+
+// Calculate cluster index.
+var clusterIndex = kmeans.classify([0, 0, 225]);
+```
+
+#### Accessing Centroids and K value
+
+After clustering or loading via fromJSON(), the calculated centers are accessible via the centroids property. Similarly, the K-value can be derived via centroids.length.
+
+```javascript
+// Calculate clusters.
+var clusters = kmeans.cluster(colors, 3);
+
+// Access centroids, an array of length 3.
+var centroids = kmeans.centroids;
+
+// Access k-value.
+var k = centroids.length;
+```
+
 # Hierarchical
 
 ```javascript
diff --git a/lib/clusterfck.js b/lib/clusterfck.js
index ed7c2c0..4bd4cd7 100644
--- a/lib/clusterfck.js
+++ b/lib/clusterfck.js
@@ -1,4 +1,5 @@
 module.exports = {
    hcluster: require("./hcluster"),
-   kmeans: require("./kmeans")
+   Kmeans: require("./kmeans"),
+   kmeans: require("./kmeans").kmeans
 };
\ No newline at end of file
diff --git a/lib/kmeans.js b/lib/kmeans.js
index d3879a9..3da90f0 100644
--- a/lib/kmeans.js
+++ b/lib/kmeans.js
@@ -1,6 +1,10 @@
 var distances = require("./distance");
 
-function randomCentroids(points, k) {
+function KMeans(centroids) {
+   this.centroids = centroids || [];
+}
+
+KMeans.prototype.randomCentroids = function(points, k) {
    var centroids = points.slice(0); // copy
    centroids.sort(function() {
       return (Math.round(Math.random()) - 0.5);
@@ -8,20 +12,27 @@ function randomCentroids(points, k) {
    return centroids.slice(0, k);
 }
 
-function closestCentroid(point, centroids, distance) {
+KMeans.prototype.classify = function(point, distance) {
    var min = Infinity,
        index = 0;
-   for (var i = 0; i < centroids.length; i++) {
-      var dist = distance(point, centroids[i]);
+
+   distance = distance || "euclidean";
+   if (typeof distance == "string") {
+      distance = distances[distance];
+   }
+
+   for (var i = 0; i < this.centroids.length; i++) {
+      var dist = distance(point, this.centroids[i]);
       if (dist < min) {
          min = dist;
          index = i;
       }
    }
+
    return index;
 }
 
-function kmeans(points, k, distance, snapshotPeriod, snapshotCb) {
+KMeans.prototype.cluster = function(points, k, distance, snapshotPeriod, snapshotCb) {
    k = k || Math.max(2, Math.ceil(Math.sqrt(points.length / 2)));
 
    distance = distance || "euclidean";
@@ -29,7 +40,8 @@ function kmeans(points, k, distance, snapshotPeriod, snapshotCb) {
       distance = distances[distance];
    }
 
-   var centroids = randomCentroids(points, k);
+   this.centroids = this.randomCentroids(points, k);
+
    var assignment = new Array(points.length);
    var clusters = new Array(k);
 
@@ -38,7 +50,7 @@ function kmeans(points, k, distance, snapshotPeriod, snapshotCb) {
    while (movement) {
       // update point-to-centroid assignments
       for (var i = 0; i < points.length; i++) {
-         assignment[i] = closestCentroid(points[i], centroids, distance);
+         assignment[i] = this.classify(points[i], distance);
       }
 
       // update location of each centroid
@@ -54,7 +66,8 @@ function kmeans(points, k, distance, snapshotPeriod, snapshotCb) {
          if (!assigned.length) {
             continue;
          }
-         var centroid = centroids[j];
+
+         var centroid = this.centroids[j];
          var newCentroid = new Array(centroid.length);
 
          for (var g = 0; g < centroid.length; g++) {
@@ -68,7 +81,8 @@ function kmeans(points, k, distance, snapshotPeriod, snapshotCb) {
                movement = true;
             }
          }
-         centroids[j] = newCentroid;
+
+         this.centroids[j] = newCentroid;
          clusters[j] = assigned;
       }
 
@@ -76,7 +90,21 @@ function kmeans(points, k, distance, snapshotPeriod, snapshotCb) {
          snapshotCb(clusters);
       }
    }
+
    return clusters;
 }
 
-module.exports = kmeans;
+KMeans.prototype.toJSON = function() {
+   return JSON.stringify(this.centroids);
+}
+
+KMeans.prototype.fromJSON = function(json) {
+   this.centroids = JSON.parse(json);
+   return this;
+}
+
+module.exports = KMeans;
+
+module.exports.kmeans = function(vectors, k) {
+   return (new KMeans()).cluster(vectors, k);
+}
\ No newline at end of file
